{"version":3,"file":"sha3-CHwt7_Cm.js","sources":["../../node_modules/@noble/hashes/esm/_assert.js","../../node_modules/@noble/hashes/esm/_u64.js","../../node_modules/@noble/hashes/esm/utils.js","../../node_modules/@noble/hashes/esm/sha3.js"],"sourcesContent":["function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map"],"names":["number","n","isBytes","a","bytes","b","lengths","exists","instance","checkFinished","output","out","min","U32_MASK64","_32n","fromBig","le","split","lst","Ah","Al","h","l","rotlSH","s","rotlSL","rotlBH","rotlBL","u32","arr","createView","rotr","word","shift","isLE","byteSwap","byteSwap32","i","hexes","_","bytesToHex","abytes","hex","utf8ToBytes","str","toBytes","data","Hash","wrapConstructor","hashCons","hashC","msg","tmp","wrapXOFConstructorWithOpts","opts","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","x","y","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","keccakP","rounds","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","Keccak","blockLen","suffix","outputLen","enableXOF","state","len","pos","take","bufferOut","to","gen","sha3_224","sha3_256","sha3_384","sha3_512","keccak_224","keccak_256","keccak_384","keccak_512","genShake","shake128","shake256"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}